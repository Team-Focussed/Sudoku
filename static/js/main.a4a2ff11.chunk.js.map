{"version":3,"sources":["components/Landing.jsx","sudokuJS.js","components/Timer.jsx","components/Game.jsx","App.jsx","index.js"],"names":["Landing","options","setOptions","className","required","id","value","level","onChange","e","target","disabled","hidden","size","to","onClick","console","log","window","$","undefined","fn","sudokuJS","opts","DIFFICULTY_EASY","DIFFICULTY_MEDIUM","DIFFICULTY_HARD","DIFFICULTY_VERY_HARD","SOLVE_MODE_STEP","SOLVE_MODE_ALL","DIFFICULTIES","boardSize","boardNumbers","$boardInputs","solveMode","difficulty","candidatesShowing","editingCandidates","boardFinished","boardError","onlyUpdatedCandidates","gradingMode","generatingMode","invalidCandidates","strategies","title","hlength","houses","length","i","housesCompleted","j","emptyCells","k","boardIndex","board","val","push","house","cell","emptyCell","numbersLeft","setBoardCell","uIBoardHighlightCandidate","score","visualEliminationOfCandidates","candidates","possibleCandidates","digit","digits","possibleCells","l","boardCell","contains","cellIndex","nakedCandidates","a","houseType","sameAltHouse","houseId","houseTwoId","sameAltTwoHouse","cellsWithCandidate","cellHouses","housesWithCell","newHouseId","newHouseTwoId","h","altHouseType","altHouse","cellsEffected","x","cellsUpdated","removeCandidatesFromCells","highLightCandidatesOnCells","hiddenLockedCandidates","usedStrategies","$board","this","msg","obj","uniqueArray","temp","r","calcBoardDifficulty","boardDiff","totalScore","freq","isBoardFinished","initBoard","alreadyEnhanced","nullCandidateList","Math","sqrt","attr","boardErrorFn","boxSideSize","hrow","vrow","box","boxStartIndex","floor","generateHouseIndexList","cellVal","slice","renderBoard","htmlString","renderBoardCell","append","find","candidatesString","buildCandidatesString","candidatesList","s","updateUIBoard","paintNew","removeClass","each","v","$input","newVal","addClass","siblings","html","updateUIBoardCell","removeCandidatesFromCell","c","cellUpdated","mode","cells","candidate","cellCandidates","resetBoardVariables","clearBoard","cands","getNullCandidatesList","resetCandidates","updateUI","resetCandidatesList","indexInHouse","numbers","splice","numbersTaken","n","candidatesLeft","t","cellsForCandidate","candidatesToRemove","combineInfo","minIndexes","result","checkCombinedCandidates","startIndex","max","b","cellsWithCandidates","combinedCandidates","concat","y","pop","checkLockedCandidates","effectedCells","solveFn","boardFinishedFn","difficultyInfo","nrSolveLoops","strat","boardUpdatedFn","cause","showCandidates","candidateShowToggleFn","keyboardNumberInput","input","parseInt","toggleCandidateOnCell","alreadyExistingCellInHouseWithDigit","hasClass","analyzeBoard","usedStrategiesClone","JSON","parse","stringify","boardClone","canContinue","data","error","finished","generateBoardAnswerRecursively","forceUIUpdate","invalids","filter","randomCandidate","round","random","setBoardCellWithRandomCandidate","lastIndex","easyEnough","hardEnough","digCells","given","minGiven","randIndex","generateBoard","diff","callback","boardAnswer","boardTooEasy","on","$this","replace","keyCode","currentId","newId","focus","keyboardMoveBoardFocus","solveAll","solveStep","getBoard","setBoard","newBoard","hideCandidates","setEditingCandidates","jQuery","Timer","hours","minutes","seconds","paused","setPaused","useState","time","setTime","useEffect","interval","setInterval","clearInterval","Game","history","useHistory","mySudokuJS","setMySudokoJS","pause","setPause","sudokuBoard","App","exact","path","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.a4a2ff11.chunk.js","sourcesContent":["import React from \"react\";\nimport \"../components/stylings/Landing.css\";\nimport { Link } from \"react-router-dom\";\nfunction Landing({ options, setOptions }) {\n\treturn (\n\t\t<div className=\"landing\">\n\t\t\t<div className=\"landing_container\">\n\t\t\t\t<h1>Sudoku Sazy</h1>\n\t\t\t\t<div className=\"options\">\n\t\t\t\t\t<div className=\"nes-select is-dark\">\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\tid=\"dark_select\"\n\t\t\t\t\t\t\tvalue={options.level}\n\t\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\t\tsetOptions({ ...options, level: e.target.value });\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option value=\"\" disabled hidden>\n\t\t\t\t\t\t\t\tLevel\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t\t<option value=\"easy\">Easy</option>\n\t\t\t\t\t\t\t<option value=\"medium\">Medium</option>\n\t\t\t\t\t\t\t<option value=\"hard\">Hard</option>\n\t\t\t\t\t\t\t<option value=\"very hard\">Very Hard</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t\t<div className=\"nes-select is-dark\">\n\t\t\t\t\t\t<select\n\t\t\t\t\t\t\trequired\n\t\t\t\t\t\t\tid=\"dark_select\"\n\t\t\t\t\t\t\tvalue={options.size}\n\t\t\t\t\t\t\tonChange={(e) => {\n\t\t\t\t\t\t\t\tsetOptions({ ...options, size: e.target.value });\n\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t>\n\t\t\t\t\t\t\t<option value=\"\" disabled hidden>\n\t\t\t\t\t\t\t\tSize\n\t\t\t\t\t\t\t</option>\n\t\t\t\t\t\t\t<option value=\"4\">4x4</option>\n\t\t\t\t\t\t\t<option value=\"9\">9x9</option>\n\t\t\t\t\t\t\t<option value=\"16\">16x16</option>\n\t\t\t\t\t\t</select>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t\t<Link to=\"/game\">\n\t\t\t\t\t<div\n\t\t\t\t\t\tclassName=\"play-btn\"\n\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\tconsole.log(options);\n\t\t\t\t\t\t}}\n\t\t\t\t\t>\n\t\t\t\t\t\t<i className=\"fas fa-play\"></i>\n\t\t\t\t\t</div>\n\t\t\t\t</Link>\n\t\t\t</div>\n\t\t</div>\n\t);\n}\n\nexport default Landing;\n","// sudokuJS v0.4.4\n// https://github.com/pocketjoso/sudokuJS\n// Author: Jonas Ohlsson\n// License: MIT\nimport jQuery from \"jquery\";\n(function (window, $, undefined) {\n\t\"use strict\";\n\t/*TODO:\n\t\t--possible additions--\n\t\ttoggle edit candidates\n\t\tundo/redo\n\t*/\n\n\t/**\n\t * Define a jQuery plugin\n\t */\n\t$.fn.sudokuJS = function (opts) {\n\t\t/*\n\t\t * constants\n\t\t *-----------*/\n\n\t\tvar DIFFICULTY_EASY = \"easy\";\n\t\tvar DIFFICULTY_MEDIUM = \"medium\";\n\t\tvar DIFFICULTY_HARD = \"hard\";\n\t\tvar DIFFICULTY_VERY_HARD = \"very hard\";\n\n\t\tvar SOLVE_MODE_STEP = \"step\";\n\t\tvar SOLVE_MODE_ALL = \"all\";\n\n\t\tvar DIFFICULTIES = [DIFFICULTY_EASY, DIFFICULTY_MEDIUM, DIFFICULTY_HARD, DIFFICULTY_VERY_HARD];\n\n\t\t/*\n\t\t * variables\n\t\t *-----------*/\n\t\topts = opts || {};\n\t\tvar solveMode = SOLVE_MODE_STEP,\n\t\t\tdifficulty = \"unknown\",\n\t\t\tcandidatesShowing = false,\n\t\t\teditingCandidates = false,\n\t\t\tboardFinished = false,\n\t\t\tboardError = false,\n\t\t\tonlyUpdatedCandidates = false,\n\t\t\tgradingMode = false, //solving without updating UI\n\t\t\tgeneratingMode = false, //silence board unsolvable errors\n\t\t\tinvalidCandidates = [], //used by the generateBoard function\n\t\t\t/*\n\t\tthe score reflects how much increased difficulty the board gets by having the pattern rather than an already solved cell\n\t\t*/\n\t\t\tstrategies = [\n\t\t\t\t{ title: \"openSingles\", fn: openSingles, score: 0.1 },\n\t\t\t\t//harder for human to spot\n\t\t\t\t{ title: \"singleCandidate\", fn: singleCandidate, score: 9 },\n\t\t\t\t{ title: \"visualElimination\", fn: visualElimination, score: 8 },\n\t\t\t\t//only eliminates one candidate, should have lower score?\n\t\t\t\t{ title: \"nakedPair\", fn: nakedPair, score: 50 },\n\t\t\t\t{ title: \"pointingElimination\", fn: pointingElimination, score: 80 },\n\t\t\t\t//harder for human to spot\n\t\t\t\t{ title: \"hiddenPair\", fn: hiddenPair, score: 90 },\n\t\t\t\t{ title: \"nakedTriplet\", fn: nakedTriplet, score: 100 },\n\t\t\t\t//never gets used unless above strats are turned off?\n\t\t\t\t{ title: \"hiddenTriplet\", fn: hiddenTriplet, score: 140 },\n\t\t\t\t//never gets used unless above strats are turned off?\n\t\t\t\t{ title: \"nakedQuad\", fn: nakedQuad, score: 150 },\n\t\t\t\t//never gets used unless above strats are turned off?\n\t\t\t\t{ title: \"hiddenQuad\", fn: hiddenQuad, score: 280 },\n\t\t\t],\n\t\t\t//nr of times each strategy has been used for solving this board - used to calculate difficulty score\n\t\t\tusedStrategies = [],\n\t\t\t/*board variable gets enhanced into list of objects on init:\n\t\t\t,{\n\t\t\t\tval: null\n\t\t\t\t,candidates: [\n\t\t\t\t\t]\n\t\t\t}\n\t\t*/\n\t\t\tboard = [],\n\t\t\tboardSize,\n\t\t\tboardNumbers, // array of 1-9 by default, generated in initBoard\n\t\t\t//indexes of cells in each house - generated on the fly based on boardSize\n\t\t\thouses = [\n\t\t\t\t//hor. rows\n\t\t\t\t[],\n\t\t\t\t//vert. rows\n\t\t\t\t[],\n\t\t\t\t//boxes\n\t\t\t\t[],\n\t\t\t];\n\n\t\t/*\n\t\t * selectors\n\t\t *-----------*/\n\t\tvar $board = $(this),\n\t\t\t$boardInputs, //created\n\t\t\t$boardInputCandidates; //created\n\n\t\t/*\n\t\t * methods\n\t\t *-----------*/\n\t\t//shortcut for logging..\n\t\tfunction log(msg) {\n\t\t\tif (window.console && console.log) console.log(msg);\n\t\t}\n\n\t\t//array contains function\n\t\tvar contains = function (a, obj) {\n\t\t\tfor (var i = 0; i < a.length; i++) {\n\t\t\t\tif (a[i] === obj) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\tvar uniqueArray = function (a) {\n\t\t\tvar temp = {};\n\t\t\tfor (var i = 0; i < a.length; i++) temp[a[i]] = true;\n\t\t\tvar r = [];\n\t\t\tfor (var k in temp) r.push(k);\n\t\t\treturn r;\n\t\t};\n\n\t\t/* calcBoardDifficulty\n\t\t * --------------\n\t\t *  TYPE: solely based on strategies required to solve board (i.e. single count per strategy)\n\t\t *  SCORE: distinguish between boards of same difficulty.. based on point system. Needs work.\n\t\t * -----------------------------------------------------------------*/\n\t\tvar calcBoardDifficulty = function (usedStrategies) {\n\t\t\tvar boardDiff = {};\n\t\t\tif (usedStrategies.length < 3) boardDiff.level = DIFFICULTY_EASY;\n\t\t\telse if (usedStrategies.length < 4) boardDiff.level = DIFFICULTY_MEDIUM;\n\t\t\telse boardDiff.level = DIFFICULTY_HARD;\n\n\t\t\tvar totalScore = 0;\n\t\t\tfor (var i = 0; i < strategies.length; i++) {\n\t\t\t\tvar freq = usedStrategies[i];\n\t\t\t\tif (!freq) continue; //undefined or 0, won't effect score\n\t\t\t\tvar stratObj = strategies[i];\n\t\t\t\ttotalScore += freq * stratObj.score;\n\t\t\t}\n\t\t\tboardDiff.score = totalScore;\n\t\t\t//log(\"totalScore: \"+totalScore);\n\n\t\t\tif (totalScore > 750)\n\t\t\t\t// if(totalScore > 2200)\n\t\t\t\tboardDiff.level = DIFFICULTY_VERY_HARD;\n\n\t\t\treturn boardDiff;\n\t\t};\n\n\t\t/* isBoardFinished\n\t\t * -----------------------------------------------------------------*/\n\t\tvar isBoardFinished = function () {\n\t\t\tfor (var i = 0; i < boardSize * boardSize; i++) {\n\t\t\t\tif (board[i].val === null) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t};\n\n\t\t/* generateHouseIndexList\n\t\t * -----------------------------------------------------------------*/\n\t\tvar generateHouseIndexList = function () {\n\t\t\t// reset houses\n\t\t\thouses = [\n\t\t\t\t//hor. rows\n\t\t\t\t[],\n\t\t\t\t//vert. rows\n\t\t\t\t[],\n\t\t\t\t//boxes\n\t\t\t\t[],\n\t\t\t];\n\t\t\tvar boxSideSize = Math.sqrt(boardSize);\n\n\t\t\tfor (var i = 0; i < boardSize; i++) {\n\t\t\t\tvar hrow = []; //horisontal row\n\t\t\t\tvar vrow = []; //vertical row\n\t\t\t\tvar box = [];\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\throw.push(boardSize * i + j);\n\t\t\t\t\tvrow.push(boardSize * j + i);\n\n\t\t\t\t\tif (j < boxSideSize) {\n\t\t\t\t\t\tfor (var k = 0; k < boxSideSize; k++) {\n\t\t\t\t\t\t\t//0, 0,0, 27, 27,27, 54, 54, 54 for a standard sudoku\n\t\t\t\t\t\t\tvar a = Math.floor(i / boxSideSize) * boardSize * boxSideSize;\n\t\t\t\t\t\t\t//[0-2] for a standard sudoku\n\t\t\t\t\t\t\tvar b = (i % boxSideSize) * boxSideSize;\n\t\t\t\t\t\t\tvar boxStartIndex = a + b; //0 3 6 27 30 33 54 57 60\n\n\t\t\t\t\t\t\t//every boxSideSize box, skip boardSize num rows to next box (on new horizontal row)\n\t\t\t\t\t\t\t//Math.floor(i/boxSideSize)*boardSize*2\n\t\t\t\t\t\t\t//skip across horizontally to next box\n\t\t\t\t\t\t\t//+ i*boxSideSize;\n\n\t\t\t\t\t\t\tbox.push(boxStartIndex + boardSize * j + k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thouses[0].push(hrow);\n\t\t\t\thouses[1].push(vrow);\n\t\t\t\thouses[2].push(box);\n\t\t\t}\n\t\t};\n\n\t\t/* initBoard\n\t\t * --------------\n\t\t *  inits board, variables.\n\t\t * -----------------------------------------------------------------*/\n\t\tvar initBoard = function (opts) {\n\t\t\tvar alreadyEnhanced = board[0] !== null && typeof board[0] === \"object\";\n\t\t\tvar nullCandidateList = [];\n\t\t\tboardNumbers = [];\n\t\t\tboardSize = (!board.length && opts.boardSize) || Math.sqrt(board.length) || 9;\n\t\t\t$board.attr(\"data-board-size\", boardSize);\n\t\t\tif (boardSize % 1 !== 0 || Math.sqrt(boardSize) % 1 !== 0) {\n\t\t\t\tlog(\"invalid boardSize: \" + boardSize);\n\t\t\t\tif (typeof opts.boardErrorFn === \"function\") opts.boardErrorFn({ msg: \"invalid board size\" });\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor (var i = 0; i < boardSize; i++) {\n\t\t\t\tboardNumbers.push(i + 1);\n\t\t\t\tnullCandidateList.push(null);\n\t\t\t}\n\t\t\tgenerateHouseIndexList();\n\n\t\t\tif (!alreadyEnhanced) {\n\t\t\t\t//enhance board to handle candidates, and possibly other params\n\t\t\t\tfor (var j = 0; j < boardSize * boardSize; j++) {\n\t\t\t\t\tvar cellVal = typeof board[j] === \"undefined\" ? null : board[j];\n\t\t\t\t\tvar candidates = cellVal === null ? boardNumbers.slice() : nullCandidateList.slice();\n\t\t\t\t\tboard[j] = {\n\t\t\t\t\t\tval: cellVal,\n\t\t\t\t\t\tcandidates: candidates,\n\t\t\t\t\t\t//title: \"\" possibl add in 'A1. B1...etc\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/* renderBoard\n\t\t * --------------\n\t\t *  dynamically renders the board on the screen (into the DOM), based on board variable\n\t\t * -----------------------------------------------------------------*/\n\t\tvar renderBoard = function () {\n\t\t\t//log(\"renderBoard\");\n\t\t\t//log(board);\n\t\t\tvar htmlString = \"\";\n\t\t\tfor (var i = 0; i < boardSize * boardSize; i++) {\n\t\t\t\thtmlString += renderBoardCell(board[i], i);\n\n\t\t\t\tif ((i + 1) % boardSize === 0) {\n\t\t\t\t\thtmlString += \"<br>\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t//log(htmlString);\n\t\t\t$board.append(htmlString);\n\n\t\t\t//save important board elements\n\t\t\t$boardInputs = $board.find(\"input\");\n\t\t\t$boardInputCandidates = $board.find(\".candidates\");\n\t\t};\n\n\t\t/* renderBoardCell\n\t\t * -----------------------------------------------------------------*/\n\t\tvar renderBoardCell = function (boardCell, id) {\n\t\t\tvar val = boardCell.val === null ? \"\" : boardCell.val;\n\t\t\tvar candidates = boardCell.candidates || [];\n\t\t\tvar candidatesString = buildCandidatesString(candidates);\n\t\t\tvar maxlength = boardSize < 10 ? \" maxlength='1'\" : \"\";\n\t\t\treturn (\n\t\t\t\t\"<div class='sudoku-board-cell'>\" +\n\t\t\t\t//want to use type=number, but then have to prevent chrome scrolling and up down key behaviors..\n\t\t\t\t\"<input type='text' pattern='\\\\d*' novalidate id='input-\" +\n\t\t\t\tid +\n\t\t\t\t\"' value='\" +\n\t\t\t\tval +\n\t\t\t\t\"'\" +\n\t\t\t\tmaxlength +\n\t\t\t\t\">\" +\n\t\t\t\t\"<div id='input-\" +\n\t\t\t\tid +\n\t\t\t\t\"-candidates' class='candidates'>\" +\n\t\t\t\tcandidatesString +\n\t\t\t\t\"</div>\" +\n\t\t\t\t\"</div>\"\n\t\t\t);\n\t\t};\n\n\t\t/* buildCandidatesString\n\t\t * -----------------------------------------------------------------*/\n\t\tvar buildCandidatesString = function (candidatesList) {\n\t\t\tvar s = \"\";\n\t\t\tfor (var i = 1; i < boardSize + 1; i++) {\n\t\t\t\tif (contains(candidatesList, i)) s += \"<div>\" + i + \"</div> \";\n\t\t\t\telse s += \"<div>&nbsp;</div> \";\n\t\t\t}\n\t\t\treturn s;\n\t\t};\n\n\t\t/* updateUI\n\t\t * --------------\n\t\t *  updates the UI\n\t\t * -----------------------------------------------------------------\n\t\tvar updateUI = function(opts){\n\t\t\tvar opts = opts || {};\n\t\t\tvar paintNew = (typeof opts.paintNew !== \"undefined\") ? opts.paintNew : true;\n\t\t\tupdateUIBoard(paintNew);\n\t\t}*/\n\n\t\t/* updateUIBoard -\n\t\t * --------------\n\t\t *  updates the board with our latest values\n\t\t * -----------------------------------------------------------------*/\n\t\tvar updateUIBoard = function (paintNew) {\n\t\t\t//log(\"re painting every input on board..\");\n\t\t\t$boardInputs.removeClass(\"highlight-val\").each(function (i, v) {\n\t\t\t\tvar $input = $(this);\n\t\t\t\tvar newVal = board[i].val;\n\t\t\t\t//if(newVal && parseInt($input.val()) !== newVal) {\n\t\t\t\t$input.val(newVal);\n\t\t\t\tif (paintNew) $input.addClass(\"highlight-val\");\n\t\t\t\t//}\n\t\t\t\tvar $candidates = $input.siblings(\".candidates\");\n\t\t\t\t$candidates.html(buildCandidatesString(board[i].candidates));\n\t\t\t});\n\t\t};\n\n\t\t/* updateUIBoardCell -\n\t\t * --------------\n\t\t *  updates ONE cell on the board with our latest values\n\t\t * -----------------------------------------------------------------*/\n\t\tvar updateUIBoardCell = function (cellIndex, opts) {\n\t\t\topts = opts || {};\n\t\t\t//log(\"updateUIBoardCell: \"+cellIndex);\n\t\t\t//if(!(opts.mode && opts.mode === \"only-candidates\")){\n\t\t\tvar newVal = board[cellIndex].val;\n\n\t\t\t//$boardInputs.removeClass(\"highlight-val\");\n\n\t\t\t//shouldn't always add hightlight-val class\n\t\t\t$(\"#input-\" + cellIndex)\n\t\t\t\t.val(newVal)\n\t\t\t\t.addClass(\"highlight-val\");\n\t\t\t//}\n\t\t\t$(\"#input-\" + cellIndex + \"-candidates\").html(buildCandidatesString(board[cellIndex].candidates));\n\t\t};\n\n\t\t/* uIBoardHighlightRemoveCandidate\n\t\t * --------------\n\t\t *  highlight candidate in cell that is about to be removed\n\t\t * -----------------------------------------------------------------*/\n\t\tvar uIBoardHighlightRemoveCandidate = function (cellIndex, digit) {\n\t\t\t$(\"#input-\" + cellIndex + \"-candidates div:nth-of-type(\" + digit + \")\").addClass(\"candidate--to-remove\");\n\t\t};\n\n\t\t/* uIBoardHighlightCandidate -\n\t\t * --------------\n\t\t *  highight candidate in cell that helps eliminate another candidate\n\t\t * -----------------------------------------------------------------*/\n\t\tvar uIBoardHighlightCandidate = function (cellIndex, digit) {\n\t\t\t$(\"#input-\" + cellIndex + \"-candidates div:nth-of-type(\" + digit + \")\").addClass(\"candidate--highlight\");\n\t\t};\n\n\t\t/* removeCandidatesFromCell\n\t\t-----------------------------------------------------------------*/\n\t\tvar removeCandidatesFromCell = function (cell, candidates) {\n\t\t\tvar boardCell = board[cell];\n\t\t\tvar c = boardCell.candidates;\n\t\t\tvar cellUpdated = false;\n\t\t\tfor (var i = 0; i < candidates.length; i++) {\n\t\t\t\t//-1 because candidate '1' is at index 0 etc.\n\t\t\t\tif (c[candidates[i] - 1] !== null) {\n\t\t\t\t\tc[candidates[i] - 1] = null; //writes to board variable\n\t\t\t\t\tcellUpdated = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cellUpdated && solveMode === SOLVE_MODE_STEP) updateUIBoardCell(cell, { mode: \"only-candidates\" });\n\t\t};\n\n\t\t/* removeCandidatesFromCells\n\t\t * ---returns list of cells where any candidats where removed\n\t\t-----------------------------------------------------------------*/\n\t\tvar removeCandidatesFromCells = function (cells, candidates) {\n\t\t\t//log(\"removeCandidatesFromCells\");\n\t\t\tvar cellsUpdated = [];\n\t\t\tfor (var i = 0; i < cells.length; i++) {\n\t\t\t\tvar c = board[cells[i]].candidates;\n\n\t\t\t\tfor (var j = 0; j < candidates.length; j++) {\n\t\t\t\t\tvar candidate = candidates[j];\n\t\t\t\t\t//-1 because candidate '1' is at index 0 etc.\n\t\t\t\t\tif (c[candidate - 1] !== null) {\n\t\t\t\t\t\tc[candidate - 1] = null; //NOTE: also deletes them from board variable\n\t\t\t\t\t\tcellsUpdated.push(cells[i]); //will push same cell multiple times\n\n\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP) {\n\t\t\t\t\t\t\t//highlight candidate as to be removed on board\n\t\t\t\t\t\t\tuIBoardHighlightRemoveCandidate(cells[i], candidate);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn cellsUpdated;\n\t\t};\n\n\t\tvar highLightCandidatesOnCells = function (candidates, cells) {\n\t\t\tfor (var i = 0; i < cells.length; i++) {\n\t\t\t\tvar cellCandidates = board[cells[i]].candidates;\n\n\t\t\t\tfor (var j = 0; j < cellCandidates.length; j++) {\n\t\t\t\t\tif (contains(candidates, cellCandidates[j])) uIBoardHighlightCandidate(cells[i], cellCandidates[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tvar resetBoardVariables = function () {\n\t\t\tboardFinished = false;\n\t\t\tboardError = false;\n\t\t\tonlyUpdatedCandidates = false;\n\t\t\tusedStrategies = [];\n\t\t\tgradingMode = false;\n\t\t};\n\n\t\t/* clearBoard\n\t\t-----------------------------------------------------------------*/\n\t\tvar clearBoard = function () {\n\t\t\tresetBoardVariables();\n\n\t\t\t//reset board variable\n\t\t\tvar cands = boardNumbers.slice(0);\n\t\t\tfor (var i = 0; i < boardSize * boardSize; i++) {\n\t\t\t\tboard[i] = {\n\t\t\t\t\tval: null,\n\t\t\t\t\tcandidates: cands.slice(),\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t//reset UI\n\t\t\t$boardInputs.removeClass(\"highlight-val\").val(\"\");\n\n\t\t\tupdateUIBoard(false);\n\t\t};\n\n\t\tvar getNullCandidatesList = function () {\n\t\t\tvar l = [];\n\t\t\tfor (var i = 0; i < boardSize; i++) {\n\t\t\t\tl.push(null);\n\t\t\t}\n\t\t\treturn l;\n\t\t};\n\n\t\t/* resetCandidates\n\t\t-----------------------------------------------------------------*/\n\t\tvar resetCandidates = function (updateUI) {\n\t\t\tvar resetCandidatesList = boardNumbers.slice(0);\n\t\t\tfor (var i = 0; i < boardSize * boardSize; i++) {\n\t\t\t\tif (board[i].val === null) {\n\t\t\t\t\tboard[i].candidates = resetCandidatesList.slice(); //otherwise same list (not reference!) on every cell\n\t\t\t\t\tif (updateUI !== false)\n\t\t\t\t\t\t$(\"#input-\" + i + \"-candidates\").html(buildCandidatesString(resetCandidatesList));\n\t\t\t\t} else if (updateUI !== false) {\n\t\t\t\t\t$(\"#input-\" + i + \"-candidates\").html(\"\");\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t/* setBoardCell - does not update UI\n\t\t-----------------------------------------------------------------*/\n\t\tvar setBoardCell = function (cellIndex, val) {\n\t\t\tvar boardCell = board[cellIndex];\n\t\t\t//update val\n\t\t\tboardCell.val = val;\n\t\t\tif (val !== null) boardCell.candidates = getNullCandidatesList();\n\t\t};\n\n\t\t/* indexInHouse\n\t\t * --------------\n\t\t *  returns index (0-9) for digit in house, false if not in house\n\t\t *  NOTE: careful evaluating returned index is IN row, as 0==false.\n\t\t * -----------------------------------------------------------------*/\n\t\tvar indexInHouse = function (digit, house) {\n\t\t\tfor (var i = 0; i < boardSize; i++) {\n\t\t\t\tif (board[house[i]].val === digit) return i;\n\t\t\t}\n\t\t\t//not in house\n\t\t\treturn false;\n\t\t};\n\n\t\t/* housesWithCell\n\t\t * --------------\n\t\t *  returns houses that a cell belongs to\n\t\t * -----------------------------------------------------------------*/\n\t\tvar housesWithCell = function (cellIndex) {\n\t\t\tvar boxSideSize = Math.sqrt(boardSize);\n\t\t\tvar houses = [];\n\t\t\t//horisontal row\n\t\t\tvar hrow = Math.floor(cellIndex / boardSize);\n\t\t\thouses.push(hrow);\n\t\t\t//vertical row\n\t\t\tvar vrow = Math.floor(cellIndex % boardSize);\n\t\t\thouses.push(vrow);\n\t\t\t//box\n\t\t\tvar box = Math.floor(hrow / boxSideSize) * boxSideSize + Math.floor(vrow / boxSideSize);\n\t\t\thouses.push(box);\n\n\t\t\treturn houses;\n\t\t};\n\n\t\t/* numbersLeft\n\t\t * --------------\n\t\t *  returns unused numbers in a house\n\t\t * -----------------------------------------------------------------*/\n\t\tvar numbersLeft = function (house) {\n\t\t\tvar numbers = boardNumbers.slice();\n\t\t\tfor (var i = 0; i < house.length; i++) {\n\t\t\t\tfor (var j = 0; j < numbers.length; j++) {\n\t\t\t\t\t//remove all numbers that are already being used\n\t\t\t\t\tif (numbers[j] === board[house[i]].val) numbers.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//return remaining numbers\n\t\t\treturn numbers;\n\t\t};\n\n\t\t/* numbersTaken\n\t\t * --------------\n\t\t *  returns used numbers in a house\n\t\t * -----------------------------------------------------------------*/\n\t\tvar numbersTaken = function (house) {\n\t\t\tvar numbers = [];\n\t\t\tfor (var i = 0; i < house.length; i++) {\n\t\t\t\tvar n = board[house[i]].val;\n\t\t\t\tif (n !== null) numbers.push(n);\n\t\t\t}\n\t\t\t//return remaining numbers\n\t\t\treturn numbers;\n\t\t};\n\n\t\t/* candidatesLeft\n\t\t * --------------\n\t\t *  returns list of candidates for cell (with null's removed)\n\t\t * -----------------------------------------------------------------*/\n\t\tvar candidatesLeft = function (cellIndex) {\n\t\t\tvar t = [];\n\t\t\tvar candidates = board[cellIndex].candidates;\n\t\t\tfor (var i = 0; i < candidates.length; i++) {\n\t\t\t\tif (candidates[i] !== null) t.push(candidates[i]);\n\t\t\t}\n\t\t\treturn t;\n\t\t};\n\n\t\t/* cellsForCandidate\n\t\t * --------------\n\t\t *  returns list of possible cells (cellIndex) for candidate (in a house)\n\t\t * -----------------------------------------------------------------*/\n\t\tvar cellsForCandidate = function (candidate, house) {\n\t\t\tvar t = [];\n\t\t\tfor (var i = 0; i < house.length; i++) {\n\t\t\t\tvar cell = board[house[i]];\n\t\t\t\tvar candidates = cell.candidates;\n\t\t\t\tif (contains(candidates, candidate)) t.push(house[i]);\n\t\t\t}\n\t\t\treturn t;\n\t\t};\n\n\t\t/* openSingles\n\t\t * --------------\n\t\t *  checks for houses with just one empty cell - fills it in board variable if so\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction openSingles() {\n\t\t\t//log(\"looking for openSingles\");\n\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var i = 0; i < hlength; i++) {\n\t\t\t\t//for each such house\n\t\t\t\tvar housesCompleted = 0; //if goes up to 9, sudoku is finished\n\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\tvar emptyCells = [];\n\n\t\t\t\t\t// for each cell..\n\t\t\t\t\tfor (var k = 0; k < boardSize; k++) {\n\t\t\t\t\t\tvar boardIndex = houses[i][j][k];\n\t\t\t\t\t\tif (board[boardIndex].val === null) {\n\t\t\t\t\t\t\temptyCells.push({ house: houses[i][j], cell: boardIndex });\n\t\t\t\t\t\t\tif (emptyCells.length > 1) {\n\t\t\t\t\t\t\t\t//log(\"more than one empty cell, house area :[\"+i+\"][\"+j+\"]\");\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//one empty cell found\n\t\t\t\t\tif (emptyCells.length === 1) {\n\t\t\t\t\t\tvar emptyCell = emptyCells[0];\n\t\t\t\t\t\t//grab number to fill in in cell\n\t\t\t\t\t\tvar val = numbersLeft(emptyCell.house);\n\t\t\t\t\t\tif (val.length > 1) {\n\t\t\t\t\t\t\t//log(\"openSingles found more than one answer for: \"+emptyCell.cell+\" .. board incorrect!\");\n\t\t\t\t\t\t\tboardError = true; //to force solve all loop to stop\n\t\t\t\t\t\t\treturn -1; //error\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//log(\"fill in single empty cell \" + emptyCell.cell+\", val: \"+val);\n\n\t\t\t\t\t\tsetBoardCell(emptyCell.cell, val[0]); //does not update UI\n\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP) uIBoardHighlightCandidate(emptyCell.cell, val[0]);\n\n\t\t\t\t\t\treturn [emptyCell.cell];\n\t\t\t\t\t}\n\t\t\t\t\t//no empty ells..\n\t\t\t\t\tif (emptyCells.length === 0) {\n\t\t\t\t\t\thousesCompleted++;\n\t\t\t\t\t\t//log(i+\" \"+j+\": \"+housesCompleted);\n\t\t\t\t\t\tif (housesCompleted === boardSize) {\n\t\t\t\t\t\t\tboardFinished = true;\n\t\t\t\t\t\t\treturn -1; //special case, done\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* visualEliminationOfCandidates\n\t\t * --------------\n\t\t * ALWAYS returns false\n\t\t * -- special compared to other strats: doesn't step - updates whole board,\n\t\t in one go. Since it also only updates candidates, we can skip straight to next strat, since we know that neither this one nor the one(s) before (that only look at actual numbers on board), will find anything new.\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction visualEliminationOfCandidates() {\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var i = 0; i < hlength; i++) {\n\t\t\t\t//for each such house\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\tvar house = houses[i][j];\n\t\t\t\t\tvar candidatesToRemove = numbersTaken(house);\n\t\t\t\t\t//log(candidatesToRemove);\n\n\t\t\t\t\t// for each cell..\n\t\t\t\t\tfor (var k = 0; k < boardSize; k++) {\n\t\t\t\t\t\tvar cell = house[k];\n\t\t\t\t\t\tvar candidates = board[cell].candidates;\n\t\t\t\t\t\tremoveCandidatesFromCell(cell, candidatesToRemove);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* visualElimination\n\t\t * --------------\n\t\t * Looks for houses where a digit only appears in one slot\n\t\t * -meaning we know the digit goes in that slot.\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction visualElimination() {\n\t\t\t//log(\"visualElimination\");\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var i = 0; i < hlength; i++) {\n\t\t\t\t//for each such house\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\tvar house = houses[i][j];\n\t\t\t\t\tvar digits = numbersLeft(house);\n\n\t\t\t\t\t//for each digit left for that house\n\t\t\t\t\tfor (var k = 0; k < digits.length; k++) {\n\t\t\t\t\t\tvar digit = digits[k];\n\t\t\t\t\t\tvar possibleCells = [];\n\n\t\t\t\t\t\t//for each cell in house\n\t\t\t\t\t\tfor (var l = 0; l < boardSize; l++) {\n\t\t\t\t\t\t\tvar cell = house[l];\n\t\t\t\t\t\t\tvar boardCell = board[cell];\n\t\t\t\t\t\t\t//if the digit only appears as a candidate in one slot, that's where it has to go\n\t\t\t\t\t\t\tif (contains(boardCell.candidates, digit)) {\n\t\t\t\t\t\t\t\tpossibleCells.push(cell);\n\t\t\t\t\t\t\t\tif (possibleCells.length > 1) break; //no we can't tell anything in this case\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (possibleCells.length === 1) {\n\t\t\t\t\t\t\tvar cellIndex = possibleCells[0];\n\n\t\t\t\t\t\t\t//log(\"only slot where \"+digit+\" appears in house. \");\n\n\t\t\t\t\t\t\tsetBoardCell(cellIndex, digit); //does not update UI\n\n\t\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP) uIBoardHighlightCandidate(cellIndex, digit);\n\n\t\t\t\t\t\t\tonlyUpdatedCandidates = false;\n\t\t\t\t\t\t\treturn [cellIndex]; //one step at the time\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* singleCandidate\n\t\t * --------------\n\t\t * Looks for cells with only one candidate\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction singleCandidate() {\n\t\t\t//before we start with candidate strategies, we need to update candidates from last round:\n\t\t\tvisualEliminationOfCandidates(); //TODO: a bit hackyy, should probably not be here\n\n\t\t\t//for each cell\n\n\t\t\tfor (var i = 0; i < board.length; i++) {\n\t\t\t\tvar cell = board[i];\n\t\t\t\tvar candidates = cell.candidates;\n\n\t\t\t\t//for each candidate for that cell\n\t\t\t\tvar possibleCandidates = [];\n\t\t\t\tfor (var j = 0; j < candidates.length; j++) {\n\t\t\t\t\tif (candidates[j] !== null) possibleCandidates.push(candidates[j]);\n\t\t\t\t\tif (possibleCandidates.length > 1) break; //can't find answer here\n\t\t\t\t}\n\t\t\t\tif (possibleCandidates.length === 1) {\n\t\t\t\t\tvar digit = possibleCandidates[0];\n\n\t\t\t\t\t//log(\"only one candidate in cell: \"+digit+\" in house. \");\n\n\t\t\t\t\tsetBoardCell(i, digit); //does not update UI\n\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP) uIBoardHighlightCandidate(i, digit);\n\n\t\t\t\t\tonlyUpdatedCandidates = false;\n\t\t\t\t\treturn [i]; //one step at the time\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* pointingElimination\n\t\t * --------------\n\t\t * if candidates of a type (digit) in a box only appar on one row, all other\n\t\t * same type candidates can be removed from that row\n\t\t ------------OR--------------\n\t\t * same as above, but row instead of box, and vice versa.\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction pointingElimination() {\n\t\t\tvar effectedCells = false;\n\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var a = 0; a < hlength; a++) {\n\t\t\t\tvar houseType = a;\n\n\t\t\t\tfor (var i = 0; i < boardSize; i++) {\n\t\t\t\t\tvar house = houses[houseType][i];\n\n\t\t\t\t\t//for each digit left for this house\n\t\t\t\t\tvar digits = numbersLeft(house);\n\t\t\t\t\tfor (var j = 0; j < digits.length; j++) {\n\t\t\t\t\t\tvar digit = digits[j];\n\t\t\t\t\t\t//check if digit (candidate) only appears in one row (if checking boxes),\n\t\t\t\t\t\t//, or only in one box (if checking rows)\n\n\t\t\t\t\t\tvar sameAltHouse = true; //row if checking box, and vice versa\n\t\t\t\t\t\tvar houseId = -1;\n\t\t\t\t\t\t//when point checking from box, need to compare both kind of rows\n\t\t\t\t\t\t//that box cells are also part of, so use houseTwoId as well\n\t\t\t\t\t\tvar houseTwoId = -1;\n\t\t\t\t\t\tvar sameAltTwoHouse = true;\n\t\t\t\t\t\tvar cellsWithCandidate = [];\n\t\t\t\t\t\t//var cellDistance = null;\n\n\t\t\t\t\t\t//for each cell\n\t\t\t\t\t\tfor (var k = 0; k < house.length; k++) {\n\t\t\t\t\t\t\tvar cell = house[k];\n\n\t\t\t\t\t\t\tif (contains(board[cell].candidates, digit)) {\n\t\t\t\t\t\t\t\tvar cellHouses = housesWithCell(cell);\n\t\t\t\t\t\t\t\tvar newHouseId = houseType === 2 ? cellHouses[0] : cellHouses[2];\n\t\t\t\t\t\t\t\tvar newHouseTwoId = houseType === 2 ? cellHouses[1] : cellHouses[2];\n\n\t\t\t\t\t\t\t\t//if(cellsWithCandidate.length > 0){ //why thice the same?\n\n\t\t\t\t\t\t\t\tif (cellsWithCandidate.length > 0) {\n\t\t\t\t\t\t\t\t\tif (newHouseId !== houseId) {\n\t\t\t\t\t\t\t\t\t\tsameAltHouse = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (houseTwoId !== newHouseTwoId) {\n\t\t\t\t\t\t\t\t\t\tsameAltTwoHouse = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (sameAltHouse === false && sameAltTwoHouse === false) {\n\t\t\t\t\t\t\t\t\t\tbreak; //not in same altHouse (box/row)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t//}\n\t\t\t\t\t\t\t\thouseId = newHouseId;\n\t\t\t\t\t\t\t\thouseTwoId = newHouseTwoId;\n\t\t\t\t\t\t\t\tcellsWithCandidate.push(cell);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((sameAltHouse === true || sameAltTwoHouse === true) && cellsWithCandidate.length > 0) {\n\t\t\t\t\t\t\t//log(\"sameAltHouse..\");\n\t\t\t\t\t\t\t//we still need to check that this actually eliminates something, i.e. these possible cells can't be only in house\n\n\t\t\t\t\t\t\t//first figure out what kind of house we are talking about..\n\t\t\t\t\t\t\tvar h = housesWithCell(cellsWithCandidate[0]);\n\t\t\t\t\t\t\tvar altHouseType = 2;\n\t\t\t\t\t\t\tif (houseType === 2) {\n\t\t\t\t\t\t\t\tif (sameAltHouse) altHouseType = 0;\n\t\t\t\t\t\t\t\telse altHouseType = 1;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tvar altHouse = houses[altHouseType][h[altHouseType]];\n\t\t\t\t\t\t\tvar cellsEffected = [];\n\n\t\t\t\t\t\t\t//log(\"houses[\"+houseType+\"][\"+h[houseType]+\"].length: \"+houses[houseType][h[houseType]].length);\n\n\t\t\t\t\t\t\t//need to remove cellsWithCandidate - from cells to remove from\n\t\t\t\t\t\t\tfor (var x = 0; x < altHouse.length; x++) {\n\t\t\t\t\t\t\t\tif (!contains(cellsWithCandidate, altHouse[x])) {\n\t\t\t\t\t\t\t\t\tcellsEffected.push(altHouse[x]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//log(\"houses[\"+houseType+\"][\"+h[houseType]+\"].length: \"+houses[houseType][h[houseType]].length);\n\n\t\t\t\t\t\t\t//remove all candidates on altHouse, outside of house\n\t\t\t\t\t\t\tvar cellsUpdated = removeCandidatesFromCells(cellsEffected, [digit]);\n\n\t\t\t\t\t\t\tif (cellsUpdated.length > 0) {\n\t\t\t\t\t\t\t\t// log(\"pointing: digit \"+digit+\", from houseType: \"+houseType);\n\n\t\t\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP)\n\t\t\t\t\t\t\t\t\thighLightCandidatesOnCells([digit], cellsWithCandidate);\n\n\t\t\t\t\t\t\t\tonlyUpdatedCandidates = true;\n\n\t\t\t\t\t\t\t\t//return cellsUpdated.concat(cellsWithCandidate);\n\t\t\t\t\t\t\t\t//only return cells where we actually update candidates\n\t\t\t\t\t\t\t\treturn cellsUpdated;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/* nakedCandidates\n\t\t * --------------\n\t\t * looks for n nr of cells in house, which together has exactly n unique candidates.\n\t\t\tthis means these candidates will go into these cells, and can be removed elsewhere in house.\n\t\t *\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction nakedCandidates(n) {\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var i = 0; i < hlength; i++) {\n\t\t\t\t//for each such house\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\t//log(\"[\"+i+\"]\"+\"[\"+j+\"]\");\n\t\t\t\t\tvar house = houses[i][j];\n\t\t\t\t\tif (numbersLeft(house).length <= n)\n\t\t\t\t\t\t//can't eliminate any candidates\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar combineInfo = []; //{cell: x, candidates: []}, {} ..\n\t\t\t\t\t//combinedCandidates,cellsWithCandidate;\n\t\t\t\t\tvar minIndexes = [-1];\n\t\t\t\t\t//log(\"--------------\");\n\t\t\t\t\t//log(\"house: [\"+i+\"][\"+j+\"]\");\n\n\t\t\t\t\t//checks every combo of n candidates in house, returns pattern, or false\n\t\t\t\t\tvar result = checkCombinedCandidates(house, 0);\n\t\t\t\t\tif (result !== false) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; //pattern not found\n\n\t\t\tfunction checkCombinedCandidates(house, startIndex) {\n\t\t\t\t//log(\"startIndex: \"+startIndex);\n\t\t\t\tfor (var i = Math.max(startIndex, minIndexes[startIndex]); i < boardSize - n + startIndex; i++) {\n\t\t\t\t\t//log(i);\n\n\t\t\t\t\t//never check this cell again, in this loop\n\t\t\t\t\tminIndexes[startIndex] = i + 1;\n\t\t\t\t\t//or in a this loop deeper down in recursions\n\t\t\t\t\tminIndexes[startIndex + 1] = i + 1;\n\n\t\t\t\t\t//if(startIndex === 0){\n\t\t\t\t\t//\tcombinedCandidates = [];\n\t\t\t\t\t//\tcellsWithCandidate = []; //reset\n\t\t\t\t\t//}\n\t\t\t\t\tvar cell = house[i];\n\t\t\t\t\tvar cellCandidates = candidatesLeft(cell);\n\n\t\t\t\t\tif (cellCandidates.length === 0 || cellCandidates.length > n) continue;\n\n\t\t\t\t\t//try adding this cell and it's cellCandidates,\n\t\t\t\t\t//but first need to check that that doesn't make (unique) amount of\n\t\t\t\t\t//candidates in combineInfo > n\n\n\t\t\t\t\t//if this is the first item we add, we don't need this check (above one is enough)\n\t\t\t\t\tif (combineInfo.length > 0) {\n\t\t\t\t\t\tvar temp = cellCandidates.slice();\n\t\t\t\t\t\tfor (var a = 0; a < combineInfo.length; a++) {\n\t\t\t\t\t\t\tvar candidates = combineInfo[a].candidates;\n\t\t\t\t\t\t\tfor (var b = 0; b < candidates.length; b++) {\n\t\t\t\t\t\t\t\tif (!contains(temp, candidates[b])) temp.push(candidates[b]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (temp.length > n) {\n\t\t\t\t\t\t\tcontinue; //combined candidates spread over > n cells, won't work\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcombineInfo.push({ cell: cell, candidates: cellCandidates });\n\n\t\t\t\t\tif (startIndex < n - 1) {\n\t\t\t\t\t\t//still need to go deeper into combo\n\t\t\t\t\t\tvar r = checkCombinedCandidates(house, startIndex + 1);\n\t\t\t\t\t\t//when we come back, check if that's because we found answer.\n\t\t\t\t\t\t//if so, return with it, otherwise, keep looking\n\t\t\t\t\t\tif (r !== false) return r;\n\t\t\t\t\t}\n\n\t\t\t\t\t//check if we match our pattern\n\t\t\t\t\t//if we have managed to combine n-1 cells,\n\t\t\t\t\t//(we already know that combinedCandidates is > n)\n\t\t\t\t\t//then we found a match!\n\t\t\t\t\tif (combineInfo.length === n) {\n\t\t\t\t\t\t//now we need to check whether this eliminates any candidates\n\n\t\t\t\t\t\t//now we need to check whether this eliminates any candidates\n\n\t\t\t\t\t\tvar cellsWithCandidates = [];\n\t\t\t\t\t\tvar combinedCandidates = []; //not unique either..\n\t\t\t\t\t\tfor (var x = 0; x < combineInfo.length; x++) {\n\t\t\t\t\t\t\tcellsWithCandidates.push(combineInfo[x].cell);\n\t\t\t\t\t\t\tcombinedCandidates = combinedCandidates.concat(combineInfo[x].candidates);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//get all cells in house EXCEPT cellsWithCandidates\n\t\t\t\t\t\tvar cellsEffected = [];\n\t\t\t\t\t\tfor (var y = 0; y < boardSize; y++) {\n\t\t\t\t\t\t\tif (!contains(cellsWithCandidates, house[y])) {\n\t\t\t\t\t\t\t\tcellsEffected.push(house[y]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t//remove all candidates on house, except the on cells matched in pattern\n\t\t\t\t\t\tvar cellsUpdated = removeCandidatesFromCells(cellsEffected, combinedCandidates);\n\n\t\t\t\t\t\t//if it does remove candidates, we're succeded!\n\t\t\t\t\t\tif (cellsUpdated.length > 0) {\n\t\t\t\t\t\t\t//log(\"nakedCandidates: \");\n\t\t\t\t\t\t\t//log(combinedCandidates);\n\n\t\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP)\n\t\t\t\t\t\t\t\thighLightCandidatesOnCells(combinedCandidates, cellsWithCandidates);\n\n\t\t\t\t\t\t\tonlyUpdatedCandidates = true;\n\t\t\t\t\t\t\t//return cellsWithCandidates.concat(cellsUpdated);\n\n\t\t\t\t\t\t\t//return cells we actually update, duplicates removed\n\t\t\t\t\t\t\treturn uniqueArray(cellsUpdated);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t//if we added a value to our combo check, but failed to find pattern, we now need drop that value and go back up in chain and continue to check..\n\t\t\t\t\tif (combineInfo.length > startIndex - 1) {\n\t\t\t\t\t\t//log(\"nakedCans: need to pop last added values..\");\n\t\t\t\t\t\tcombineInfo.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* nakedPair\n\t\t * --------------\n\t\t * see nakedCandidateElimination for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction nakedPair() {\n\t\t\treturn nakedCandidates(2);\n\t\t}\n\n\t\t/* nakedTriplet\n\t\t * --------------\n\t\t * see nakedCandidateElimination for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction nakedTriplet() {\n\t\t\treturn nakedCandidates(3);\n\t\t}\n\n\t\t/* nakedQuad\n\t\t * --------------\n\t\t * see nakedCandidateElimination for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction nakedQuad() {\n\t\t\treturn nakedCandidates(4);\n\t\t}\n\n\t\t/* hiddenLockedCandidates\n\t\t * --------------\n\t\t * looks for n nr of cells in house, which together has exactly n unique candidates.\n\t\t\tthis means these candidates will go into these cells, and can be removed elsewhere in house.\n\t\t *\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction hiddenLockedCandidates(n) {\n\t\t\t//for each type of house..(hor row / vert row / box)\n\t\t\tvar hlength = houses.length;\n\t\t\tfor (var i = 0; i < hlength; i++) {\n\t\t\t\t//for each such house\n\t\t\t\tfor (var j = 0; j < boardSize; j++) {\n\t\t\t\t\tvar house = houses[i][j];\n\t\t\t\t\tif (numbersLeft(house).length <= n)\n\t\t\t\t\t\t//can't eliminate any candidates\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tvar combineInfo = []; //{candate: x, cellsWithCandidate: []}, {} ..\n\t\t\t\t\t//combinedCandidates,cellsWithCandidate;\n\t\t\t\t\tvar minIndexes = [-1];\n\t\t\t\t\t//log(\"--------------\");\n\t\t\t\t\t//log(\"house: [\"+i+\"][\"+j+\"]\");\n\n\t\t\t\t\t//checks every combo of n candidates in house, returns pattern, or false\n\t\t\t\t\tvar result = checkLockedCandidates(house, 0);\n\t\t\t\t\tif (result !== false) return result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false; //pattern not found\n\n\t\t\tfunction checkLockedCandidates(house, startIndex) {\n\t\t\t\t//log(\"startIndex: \"+startIndex);\n\t\t\t\tfor (var i = Math.max(startIndex, minIndexes[startIndex]); i <= boardSize - n + startIndex; i++) {\n\t\t\t\t\t//log(i);\n\t\t\t\t\t//never check this cell again, in this loop\n\t\t\t\t\tminIndexes[startIndex] = i + 1;\n\t\t\t\t\t//or in a this loop deeper down in recursions\n\t\t\t\t\tminIndexes[startIndex + 1] = i + 1;\n\n\t\t\t\t\tvar candidate = i + 1;\n\t\t\t\t\t//log(candidate);\n\n\t\t\t\t\tvar possibleCells = cellsForCandidate(candidate, house);\n\n\t\t\t\t\tif (possibleCells.length === 0 || possibleCells.length > n) continue;\n\n\t\t\t\t\t//try adding this candidate and it's possible cells,\n\t\t\t\t\t//but first need to check that that doesn't make (unique) amount of\n\t\t\t\t\t//possible cells in combineInfo > n\n\t\t\t\t\tif (combineInfo.length > 0) {\n\t\t\t\t\t\tvar temp = possibleCells.slice();\n\t\t\t\t\t\tfor (var a = 0; a < combineInfo.length; a++) {\n\t\t\t\t\t\t\tvar cells = combineInfo[a].cells;\n\t\t\t\t\t\t\tfor (var b = 0; b < cells.length; b++) {\n\t\t\t\t\t\t\t\tif (!contains(temp, cells[b])) temp.push(cells[b]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (temp.length > n) {\n\t\t\t\t\t\t\t//log(\"combined candidates spread over > n cells\");\n\t\t\t\t\t\t\tcontinue; //combined candidates spread over > n cells, won't work\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcombineInfo.push({ candidate: candidate, cells: possibleCells });\n\n\t\t\t\t\tif (startIndex < n - 1) {\n\t\t\t\t\t\t//still need to go deeper into combo\n\t\t\t\t\t\tvar r = checkLockedCandidates(house, startIndex + 1);\n\t\t\t\t\t\t//when we come back, check if that's because we found answer.\n\t\t\t\t\t\t//if so, return with it, otherwise, keep looking\n\t\t\t\t\t\tif (r !== false) return r;\n\t\t\t\t\t}\n\t\t\t\t\t//check if we match our pattern\n\t\t\t\t\t//if we have managed to combine n-1 candidates,\n\t\t\t\t\t//(we already know that cellsWithCandidates is <= n)\n\t\t\t\t\t//then we found a match!\n\t\t\t\t\tif (combineInfo.length === n) {\n\t\t\t\t\t\t//now we need to check whether this eliminates any candidates\n\n\t\t\t\t\t\tvar combinedCandidates = []; //not unique now...\n\t\t\t\t\t\tvar cellsWithCandidates = []; //not unique either..\n\t\t\t\t\t\tfor (var x = 0; x < combineInfo.length; x++) {\n\t\t\t\t\t\t\tcombinedCandidates.push(combineInfo[x].candidate);\n\t\t\t\t\t\t\tcellsWithCandidates = cellsWithCandidates.concat(combineInfo[x].cells);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar candidatesToRemove = [];\n\t\t\t\t\t\tfor (var c = 0; c < boardSize; c++) {\n\t\t\t\t\t\t\tif (!contains(combinedCandidates, c + 1)) candidatesToRemove.push(c + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//log(\"candidates to remove:\")\n\t\t\t\t\t\t//log(candidatesToRemove);\n\n\t\t\t\t\t\t//remove all other candidates from cellsWithCandidates\n\t\t\t\t\t\tvar cellsUpdated = removeCandidatesFromCells(cellsWithCandidates, candidatesToRemove);\n\n\t\t\t\t\t\t//if it does remove candidates, we're succeded!\n\t\t\t\t\t\tif (cellsUpdated.length > 0) {\n\t\t\t\t\t\t\t//log(\"hiddenLockedCandidates: \");\n\t\t\t\t\t\t\t//log(combinedCandidates);\n\n\t\t\t\t\t\t\tif (solveMode === SOLVE_MODE_STEP)\n\t\t\t\t\t\t\t\thighLightCandidatesOnCells(combinedCandidates, cellsWithCandidates);\n\n\t\t\t\t\t\t\tonlyUpdatedCandidates = true;\n\n\t\t\t\t\t\t\t//filter out duplicates\n\t\t\t\t\t\t\treturn uniqueArray(cellsWithCandidates);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (startIndex > 0) {\n\t\t\t\t\t//if we added a value to our combo check, but failed to find pattern, we now need drop that value and go back up in chain and continu to check..\n\t\t\t\t\tif (combineInfo.length > startIndex - 1) {\n\t\t\t\t\t\tcombineInfo.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\t/* hiddenPair\n\t\t * --------------\n\t\t * see hiddenLockedCandidates for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction hiddenPair() {\n\t\t\treturn hiddenLockedCandidates(2);\n\t\t}\n\n\t\t/* hiddenTriplet\n\t\t * --------------\n\t\t * see hiddenLockedCandidates for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction hiddenTriplet() {\n\t\t\treturn hiddenLockedCandidates(3);\n\t\t}\n\n\t\t/* hiddenQuad\n\t\t * --------------\n\t\t * see hiddenLockedCandidates for explanation\n\t\t * -- returns effectedCells - the updated cell(s), or false\n\t\t * -----------------------------------------------------------------*/\n\t\tfunction hiddenQuad() {\n\t\t\treturn hiddenLockedCandidates(4);\n\t\t}\n\n\t\t/* solveFn\n\t\t * --------------\n\t\t *  applies strategy i (where i represents strategy, ordered by simplicity\n\t\t *  -if strategy fails (too advanced a sudoku) AND an more advanced strategy exists:\n\t\t *\t\tcalls itself with i++\n\t\t *  returns canContinue true|false - only relevant for solveMode \"all\"\n\t\t * -----------------------------------------------------------------*/\n\t\tvar nrSolveLoops = 0;\n\t\tvar effectedCells = false;\n\n\t\tvar solveFn = function (i) {\n\t\t\t//log(i);\n\t\t\tif (boardFinished) {\n\t\t\t\tif (!gradingMode) {\n\t\t\t\t\tupdateUIBoard(false);\n\t\t\t\t\t//log(\"finished!\");\n\t\t\t\t\t//log(\"usedStrats:\")\n\t\t\t\t\t//log(usedStrategies);\n\n\t\t\t\t\t//callback\n\t\t\t\t\tif (typeof opts.boardFinishedFn === \"function\") {\n\t\t\t\t\t\topts.boardFinishedFn({\n\t\t\t\t\t\t\tdifficultyInfo: calcBoardDifficulty(usedStrategies),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn false; //we're done!\n\t\t\t} else if (solveMode === SOLVE_MODE_STEP) {\n\t\t\t\t//likely that we're updating twice if !candidatesShowing && !onlyUpdatedCandidates,\n\t\t\t\t//but we can't tell if user just toggled candidatesShowing.. so have to do it here (again).\n\t\t\t\tif (effectedCells && effectedCells !== -1) {\n\t\t\t\t\t//update candidates and/or new numbers\n\t\t\t\t\t//remove highlights from last step\n\t\t\t\t\t$boardInputs.removeClass(\"highlight-val\");\n\t\t\t\t\t$(\".candidate--highlight\").removeClass(\"candidate--highlight\");\n\t\t\t\t\t//update board with new effected cell(s) info\n\t\t\t\t\tfor (var j = 0; j < effectedCells.length; j++) {\n\t\t\t\t\t\tupdateUIBoardCell(effectedCells[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnrSolveLoops++;\n\t\t\tvar strat = strategies[i].fn;\n\t\t\t//log(\"use strat nr:\" +i);\n\t\t\teffectedCells = strat();\n\n\t\t\tif (effectedCells === false) {\n\t\t\t\tif (strategies.length > i + 1) {\n\t\t\t\t\treturn solveFn(i + 1);\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof opts.boardErrorFn === \"function\" && !generatingMode)\n\t\t\t\t\t\topts.boardErrorFn({ msg: \"no more strategies\" });\n\n\t\t\t\t\tif (!gradingMode && !generatingMode && solveMode === SOLVE_MODE_ALL) updateUIBoard(false);\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (boardError) {\n\t\t\t\tif (typeof opts.boardErrorFn === \"function\") opts.boardErrorFn({ msg: \"Board incorrect\" });\n\n\t\t\t\tif (solveMode === SOLVE_MODE_ALL) {\n\t\t\t\t\tupdateUIBoard(false); //show user current state of board... how much they need to reset for it to work again.\n\t\t\t\t}\n\n\t\t\t\treturn false; //we can't do no more solving\n\t\t\t} else if (solveMode === SOLVE_MODE_STEP) {\n\t\t\t\t// if user clicked solve step, and we're only going to fill in a new value (not messing with candidates) - then show user straight away\n\t\t\t\t//callback\n\t\t\t\tif (typeof opts.boardUpdatedFn === \"function\") {\n\t\t\t\t\topts.boardUpdatedFn({ cause: strategies[i].title, cellsUpdated: effectedCells });\n\t\t\t\t}\n\n\t\t\t\t//check if this finished the board\n\t\t\t\tif (isBoardFinished()) {\n\t\t\t\t\tboardFinished = true;\n\t\t\t\t\t//callback\n\t\t\t\t\tif (typeof opts.boardFinishedFn === \"function\") {\n\t\t\t\t\t\topts.boardFinishedFn({\n\t\t\t\t\t\t\tdifficultyInfo: calcBoardDifficulty(usedStrategies),\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t//paint the last cell straight away\n\t\t\t\t\tif (candidatesShowing) updateUIBoard(false);\n\t\t\t\t}\n\n\t\t\t\t//if a new number was filled in, show this on board\n\t\t\t\tif (!candidatesShowing && !onlyUpdatedCandidates && effectedCells && effectedCells !== -1) {\n\t\t\t\t\t//remove highlights from last step\n\t\t\t\t\t$boardInputs.removeClass(\"highlight-val\");\n\t\t\t\t\t$(\".candidate--highlight\").removeClass(\"candidate--highlight\");\n\t\t\t\t\t//update board with new effected cell(s) info\n\t\t\t\t\tfor (var k = 0; k < effectedCells.length; k++) {\n\t\t\t\t\t\tupdateUIBoardCell(effectedCells[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//we got an answer, using strategy i\n\t\t\tif (typeof usedStrategies[i] === \"undefined\") usedStrategies[i] = 0;\n\t\t\tusedStrategies[i] = usedStrategies[i] + 1;\n\t\t\t//if we only updated candidates, make sure they're showing\n\t\t\tif (!gradingMode && !candidatesShowing && onlyUpdatedCandidates) {\n\t\t\t\t// && i > 3){\n\t\t\t\tshowCandidates();\n\n\t\t\t\t//callback in case UI has toggle btn, so it can be updated\n\t\t\t\tif (typeof opts.candidateShowToggleFn === \"function\") opts.candidateShowToggleFn(true);\n\t\t\t}\n\n\t\t\treturn true; // can continue\n\t\t};\n\n\t\t/* keyboardMoveBoardFocus - puts focus on adjacent board cell\n\t\t * -----------------------------------------------------------------*/\n\t\tvar keyboardMoveBoardFocus = function (currentId, keyCode) {\n\t\t\tvar newId = currentId;\n\t\t\t//right\n\t\t\tif (keyCode === 39) newId++;\n\t\t\t//left\n\t\t\telse if (keyCode === 37) newId--;\n\t\t\t//down\n\t\t\telse if (keyCode === 40) newId = newId + boardSize;\n\t\t\t//up\n\t\t\telse if (keyCode === 38) newId = newId - boardSize;\n\n\t\t\t//out of bounds\n\t\t\tif (newId < 0 || newId > boardSize * boardSize) return;\n\n\t\t\t//focus input\n\t\t\t$(\"#input-\" + newId).focus();\n\t\t};\n\n\t\t/* toggleCandidateOnCell - used for editingCandidates mode\n\t\t * -----------------------------------------------------------------*/\n\t\tvar toggleCandidateOnCell = function (candidate, cell) {\n\t\t\tvar boardCell = board[cell];\n\t\t\tif (boardCell.val) {\n\t\t\t\treturn; // don't modify candidates when a cell already has a number\n\t\t\t}\n\t\t\tvar c = boardCell.candidates;\n\t\t\tc[candidate - 1] = c[candidate - 1] === null ? candidate : null;\n\t\t\tif (solveMode === SOLVE_MODE_STEP) updateUIBoardCell(cell, { mode: \"only-candidates\" });\n\t\t};\n\n\t\t/* keyboardNumberInput - update our board model\n\t\t * -----------------------------------------------------------------*/\n\t\tvar keyboardNumberInput = function (input, id) {\n\t\t\tvar val = parseInt(input.val());\n\t\t\tif (editingCandidates) {\n\t\t\t\ttoggleCandidateOnCell(val, id);\n\t\t\t\t// reset value on board\n\t\t\t\tinput.val(board[id].val);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t//log(id+\": \"+val +\" entered.\");\n\n\t\t\tvar candidates = getNullCandidatesList(); //[null,null....null];\n\n\t\t\tif (val > 0) {\n\t\t\t\t//invalidates Nan\n\t\t\t\t//check that this doesn't make board incorrect\n\t\t\t\tvar temp = housesWithCell(id);\n\t\t\t\t//for each type of house\n\t\t\t\tfor (var i = 0; i < houses.length; i++) {\n\t\t\t\t\tif (indexInHouse(val, houses[i][temp[i]])) {\n\t\t\t\t\t\t//digit already in house - board incorrect with user input\n\t\t\t\t\t\t// log(\"board incorrect!\");\n\t\t\t\t\t\tvar alreadyExistingCellInHouseWithDigit =\n\t\t\t\t\t\t\thouses[i][temp[i]][indexInHouse(val, houses[i][temp[i]])];\n\n\t\t\t\t\t\t//this happens in candidate mode, if we highlight on ui board before entering value, and user then enters before us.\n\t\t\t\t\t\tif (alreadyExistingCellInHouseWithDigit === id) continue;\n\n\t\t\t\t\t\t$(\"#input-\" + alreadyExistingCellInHouseWithDigit + \", #input-\" + id).addClass(\n\t\t\t\t\t\t\t\"board-cell--error\"\n\t\t\t\t\t\t);\n\t\t\t\t\t\t//make as incorrect in UI\n\n\t\t\t\t\t\t//input was incorrect, so don't update our board model\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//remove candidates..\n\t\t\t\tinput.siblings(\".candidates\").html(buildCandidatesString(candidates));\n\t\t\t\t//update board\n\t\t\t\tboard[id].candidates = candidates;\n\t\t\t\tboard[id].val = val;\n\n\t\t\t\t//check if that finished board\n\t\t\t\tif (isBoardFinished()) {\n\t\t\t\t\tboardFinished = true;\n\t\t\t\t\tlog(\"user finished board!\");\n\t\t\t\t\tif (typeof opts.boardFinishedFn === \"function\") {\n\t\t\t\t\t\topts.boardFinishedFn({\n\t\t\t\t\t\t\t//we rate the board via what strategies was used to solve it\n\t\t\t\t\t\t\t//we don't have this info if user solved it, unless we\n\t\t\t\t\t\t\t//always analyze board on init.. but that could be slow.\n\t\t\t\t\t\t\t//difficultyInfo: null\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tboardError = false; //reset, in case they fixed board - otherwise, we'll find the error again\n\t\t\t\tval = null;\n\t\t\t\t//add back candidates to UI cell\n\t\t\t\tcandidates = boardNumbers.slice();\n\t\t\t\tinput.siblings(\".candidates\").html(buildCandidatesString(candidates));\n\n\t\t\t\t//needs to happen before we resetCandidates below\n\t\t\t\tboard[id].val = val;\n\n\t\t\t\t//update candidates (if we could reverse remove candidates from this cell and outwards, we wouldn't have to redo all board)\n\t\t\t\tresetCandidates();\n\t\t\t\tvisualEliminationOfCandidates();\n\t\t\t}\n\t\t\t//log(board[1].candidates);\n\n\t\t\t//HACK: remove all errors as soon as they fix one - the other cells just get emptied on board (in UI; already were null in model)\n\t\t\tif ($(\"#input-\" + id).hasClass(\"board-cell--error\")) $boardInputs.removeClass(\"board-cell--error\");\n\n\t\t\tif (typeof opts.boardUpdatedFn === \"function\")\n\t\t\t\topts.boardUpdatedFn({ cause: \"user input\", cellsUpdated: [id] });\n\n\t\t\tonlyUpdatedCandidates = false;\n\t\t};\n\n\t\t/* toggleShowCandidates\n\t\t * -----------------------------------------------------------------*/\n\t\tvar toggleShowCandidates = function () {\n\t\t\t$board.toggleClass(\"showCandidates\");\n\t\t\tcandidatesShowing = !candidatesShowing;\n\t\t};\n\n\t\t/* analyzeBoard\n\t\t * solves a copy of the current board(without updating the UI),\n\t\t * reports back: error|finished, usedStrategies and difficulty level and score\n\t\t * -----------------------------------------------------------------*/\n\t\tvar analyzeBoard = function () {\n\t\t\tgradingMode = true;\n\t\t\tsolveMode = SOLVE_MODE_ALL;\n\t\t\tvar usedStrategiesClone = JSON.parse(JSON.stringify(usedStrategies));\n\t\t\tvar boardClone = JSON.parse(JSON.stringify(board));\n\t\t\tvar canContinue = true;\n\t\t\twhile (canContinue) {\n\t\t\t\tvar startStrat = onlyUpdatedCandidates ? 2 : 0;\n\t\t\t\tcanContinue = solveFn(startStrat);\n\t\t\t}\n\n\t\t\tvar data = {};\n\t\t\tif (boardError) {\n\t\t\t\tdata.error = \"Board incorrect\";\n\t\t\t} else {\n\t\t\t\tdata.finished = boardFinished;\n\t\t\t\tdata.usedStrategies = [];\n\t\t\t\tfor (var i = 0; i < usedStrategies.length; i++) {\n\t\t\t\t\tvar strat = strategies[i];\n\t\t\t\t\t//only return strategies that were actually used\n\t\t\t\t\tif (typeof usedStrategies[i] !== \"undefined\") {\n\t\t\t\t\t\tdata.usedStrategies[i] = {\n\t\t\t\t\t\t\ttitle: strat.title,\n\t\t\t\t\t\t\tfreq: usedStrategies[i],\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (boardFinished) {\n\t\t\t\t\tvar boardDiff = calcBoardDifficulty(usedStrategies);\n\t\t\t\t\tdata.level = boardDiff.level;\n\t\t\t\t\tdata.score = boardDiff.score;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//restore everything to state (before solving)\n\t\t\tresetBoardVariables();\n\t\t\tusedStrategies = usedStrategiesClone;\n\t\t\tboard = boardClone;\n\n\t\t\treturn data;\n\t\t};\n\n\t\tvar setBoardCellWithRandomCandidate = function (cellIndex, forceUIUpdate) {\n\t\t\t// CHECK still valid\n\t\t\tvisualEliminationOfCandidates();\n\t\t\t// DRAW RANDOM CANDIDATE\n\t\t\t// don't draw already invalidated candidates for cell\n\t\t\tvar invalids = invalidCandidates && invalidCandidates[cellIndex];\n\t\t\t// TODO: don't use JS filter - not supported enough(?)\n\t\t\tvar candidates = board[cellIndex].candidates.filter(function (candidate) {\n\t\t\t\tif (!candidate || (invalids && contains(invalids, candidate))) return false;\n\t\t\t\treturn candidate;\n\t\t\t});\n\t\t\t// if cell has 0 candidates - fail to set cell.\n\t\t\tif (candidates.length === 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tvar randIndex = Math.round(Math.random() * (candidates.length - 1));\n\t\t\tvar randomCandidate = candidates[randIndex];\n\t\t\t// UPDATE BOARD\n\t\t\tsetBoardCell(cellIndex, randomCandidate);\n\t\t\treturn true;\n\t\t};\n\n\t\tvar generateBoardAnswerRecursively = function (cellIndex) {\n\t\t\tif (cellIndex + 1 > boardSize * boardSize) {\n\t\t\t\t//done\n\t\t\t\tinvalidCandidates = [];\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (setBoardCellWithRandomCandidate(cellIndex)) {\n\t\t\t\tgenerateBoardAnswerRecursively(cellIndex + 1);\n\t\t\t} else {\n\t\t\t\tif (cellIndex <= 0) return false;\n\t\t\t\tvar lastIndex = cellIndex - 1;\n\t\t\t\tinvalidCandidates[lastIndex] = invalidCandidates[lastIndex] || [];\n\t\t\t\tinvalidCandidates[lastIndex].push(board[lastIndex].val);\n\t\t\t\t// set val back to null\n\t\t\t\tsetBoardCell(lastIndex, null);\n\t\t\t\t// reset candidates, only in model.\n\t\t\t\tresetCandidates(false);\n\t\t\t\t// reset invalid candidates for cellIndex\n\t\t\t\tinvalidCandidates[cellIndex] = [];\n\t\t\t\t// then try again\n\t\t\t\tgenerateBoardAnswerRecursively(lastIndex);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t};\n\n\t\tvar easyEnough = function (data) {\n\t\t\t// console.log(data.level);\n\t\t\tif (data.level === DIFFICULTY_EASY) return true;\n\t\t\tif (data.level === DIFFICULTY_MEDIUM) return difficulty !== DIFFICULTY_EASY;\n\t\t\tif (data.level === DIFFICULTY_HARD)\n\t\t\t\treturn difficulty !== DIFFICULTY_EASY && difficulty !== DIFFICULTY_MEDIUM;\n\t\t\tif (data.level === DIFFICULTY_VERY_HARD)\n\t\t\t\treturn (\n\t\t\t\t\tdifficulty !== DIFFICULTY_EASY && difficulty !== DIFFICULTY_MEDIUM && difficulty !== DIFFICULTY_HARD\n\t\t\t\t);\n\t\t};\n\t\tvar hardEnough = function (data) {\n\t\t\tif (difficulty === DIFFICULTY_EASY) return true;\n\t\t\tif (difficulty === DIFFICULTY_MEDIUM) return data.level !== DIFFICULTY_EASY;\n\t\t\tif (difficulty === DIFFICULTY_HARD)\n\t\t\t\treturn data.level !== DIFFICULTY_EASY && data.level !== DIFFICULTY_MEDIUM;\n\t\t\tif (difficulty === DIFFICULTY_VERY_HARD)\n\t\t\t\treturn (\n\t\t\t\t\tdata.level !== DIFFICULTY_EASY && data.level !== DIFFICULTY_MEDIUM && data.level !== DIFFICULTY_HARD\n\t\t\t\t);\n\t\t};\n\n\t\tvar digCells = function () {\n\t\t\tvar cells = [];\n\t\t\tvar given = boardSize * boardSize;\n\t\t\tvar minGiven = 17;\n\t\t\tif (difficulty === DIFFICULTY_EASY) {\n\t\t\t\tminGiven = 40;\n\t\t\t} else if (difficulty === DIFFICULTY_MEDIUM) {\n\t\t\t\tminGiven = 30;\n\t\t\t}\n\t\t\tif (boardSize < 9) {\n\t\t\t\tminGiven = 4;\n\t\t\t}\n\t\t\tfor (var i = 0; i < boardSize * boardSize; i++) {\n\t\t\t\tcells.push(i);\n\t\t\t}\n\n\t\t\twhile (cells.length > 0 && given > minGiven) {\n\t\t\t\tvar randIndex = Math.round(Math.random() * (cells.length - 1));\n\t\t\t\tvar cellIndex = cells.splice(randIndex, 1);\n\t\t\t\tvar val = board[cellIndex].val;\n\n\t\t\t\t// remove value from this cell\n\t\t\t\tsetBoardCell(cellIndex, null);\n\t\t\t\t// reset candidates, only in model.\n\t\t\t\tresetCandidates(false);\n\n\t\t\t\tvar data = analyzeBoard();\n\t\t\t\tif (data.finished !== false && easyEnough(data)) {\n\t\t\t\t\tgiven--;\n\t\t\t\t} else {\n\t\t\t\t\t// reset - don't dig this cell\n\t\t\t\t\tsetBoardCell(cellIndex, val);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// generates board puzzle, i.e. the answers for this round\n\t\t// requires that a board for boardSize has already been initiated\n\t\tvar generateBoard = function (diff, callback) {\n\t\t\tif ($boardInputs) clearBoard();\n\t\t\tif (contains(DIFFICULTIES, diff)) {\n\t\t\t\tdifficulty = diff;\n\t\t\t} else if (boardSize >= 9) {\n\t\t\t\tdifficulty = DIFFICULTY_MEDIUM;\n\t\t\t} else {\n\t\t\t\tdifficulty = DIFFICULTY_EASY;\n\t\t\t}\n\t\t\tgeneratingMode = true;\n\t\t\tsolveMode = SOLVE_MODE_ALL;\n\n\t\t\t// the board generated will possibly not be hard enough\n\t\t\t// (if you asked for \"hard\", you most likely get \"medium\")\n\t\t\tgenerateBoardAnswerRecursively(0);\n\n\t\t\t// attempt one - save the answer, and try digging multiple times.\n\t\t\tvar boardAnswer = board.slice();\n\n\t\t\tvar boardTooEasy = true;\n\n\t\t\twhile (boardTooEasy) {\n\t\t\t\tdigCells();\n\t\t\t\tvar data = analyzeBoard();\n\t\t\t\tif (hardEnough(data)) boardTooEasy = false;\n\t\t\t\telse board = boardAnswer;\n\t\t\t}\n\t\t\tsolveMode = SOLVE_MODE_STEP;\n\t\t\tif ($boardInputs) updateUIBoard();\n\n\t\t\tvisualEliminationOfCandidates();\n\n\t\t\tif (typeof callback === \"function\") {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * init/API/events\n\t\t *-----------*/\n\t\tif (!opts.board) {\n\t\t\tinitBoard(opts);\n\t\t\tgenerateBoard(opts);\n\t\t\trenderBoard();\n\t\t} else {\n\t\t\tboard = opts.board;\n\t\t\tinitBoard();\n\t\t\trenderBoard();\n\t\t\tvisualEliminationOfCandidates();\n\t\t}\n\n\t\t$boardInputs.on(\"keyup\", function (e) {\n\t\t\tvar $this = $(this);\n\t\t\tvar id = parseInt($this.attr(\"id\").replace(\"input-\", \"\"));\n\t\t\t//allow keyboard movements\n\t\t\tif (e.keyCode >= 37 && e.keyCode <= 40) {\n\t\t\t\t// || e.keyCode ===48){\n\t\t\t\tkeyboardMoveBoardFocus(id, e.keyCode);\n\t\t\t}\n\t\t});\n\t\t//listen on change because val is incorrect all the time on keyup, because have to filter out all other keys.\n\t\t$boardInputs.on(\"change\", function () {\n\t\t\tvar $this = $(this);\n\t\t\tvar id = parseInt($this.attr(\"id\").replace(\"input-\", \"\"));\n\t\t\tkeyboardNumberInput($this, id);\n\t\t});\n\n\t\t/**\n\t\t * PUBLIC methods\n\t\t * ----------------- */\n\t\tvar solveAll = function () {\n\t\t\tsolveMode = SOLVE_MODE_ALL;\n\t\t\tvar canContinue = true;\n\t\t\twhile (canContinue) {\n\t\t\t\tvar startStrat = onlyUpdatedCandidates ? 2 : 0;\n\t\t\t\tcanContinue = solveFn(startStrat);\n\t\t\t}\n\t\t};\n\n\t\tvar solveStep = function () {\n\t\t\tsolveMode = SOLVE_MODE_STEP;\n\t\t\tvar startStrat = onlyUpdatedCandidates ? 2 : 0;\n\t\t\tsolveFn(startStrat);\n\t\t};\n\n\t\tvar getBoard = function () {\n\t\t\treturn board;\n\t\t};\n\n\t\tvar setBoard = function (newBoard) {\n\t\t\tclearBoard(); // if any pre-existing\n\t\t\tboard = newBoard;\n\t\t\tinitBoard();\n\t\t\tvisualEliminationOfCandidates();\n\t\t\tupdateUIBoard(false);\n\t\t};\n\n\t\tvar hideCandidates = function () {\n\t\t\t$board.removeClass(\"showCandidates\");\n\t\t\tcandidatesShowing = false;\n\t\t};\n\t\tvar showCandidates = function () {\n\t\t\t$board.addClass(\"showCandidates\");\n\t\t\tcandidatesShowing = true;\n\t\t};\n\n\t\tvar setEditingCandidates = function (newVal) {\n\t\t\teditingCandidates = newVal;\n\t\t};\n\n\t\treturn {\n\t\t\tsolveAll: solveAll,\n\t\t\tsolveStep: solveStep,\n\t\t\tanalyzeBoard: analyzeBoard,\n\t\t\tclearBoard: clearBoard,\n\t\t\tgetBoard: getBoard,\n\t\t\tsetBoard: setBoard,\n\t\t\thideCandidates: hideCandidates,\n\t\t\tshowCandidates: showCandidates,\n\t\t\tsetEditingCandidates: setEditingCandidates,\n\t\t\tgenerateBoard: generateBoard,\n\t\t};\n\t};\n})(window, jQuery);\n","import { useEffect, useState } from \"react\";\n\nconst Timer = ({ hours = 0, minutes = 0, seconds = 0, paused, setPaused }) => {\n\tconst [time, setTime] = useState(0);\n\n\tuseEffect(() => {\n\t\tlet interval = null;\n\n\t\tif (paused === false) {\n\t\t\tinterval = setInterval(() => {\n\t\t\t\tsetTime((time) => time + 1);\n\t\t\t}, 1000);\n\t\t} else {\n\t\t\tclearInterval(interval);\n\t\t}\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t}, [paused]);\n\n\treturn (\n\t\t<div className=\"stop-watch\">\n\t\t\t{time}\n\t\t\t{/* <ControlButtons\n\t\t\t\tactive={isActive}\n\t\t\t\tisPaused={isPaused}\n\t\t\t\thandleStart={handleStart}\n\t\t\t\thandlePauseResume={handlePauseResume}\n\t\t\t\thandleReset={handleReset}\n\t\t\t/> */}\n\t\t</div>\n\t);\n};\nexport default Timer;\n","import { useEffect, useState } from \"react\";\nimport $ from \"jquery\";\nimport \"../sudokuJS\";\nimport \"../sudokuJS.css\";\nimport \"./stylings/Game.css\";\nimport { useHistory } from \"react-router\";\nimport Timer from \"./Timer\";\nconst Game = ({ options }) => {\n\tconst history = useHistory();\n\tconst [mySudokuJS, setMySudokoJS] = useState(\"\");\n\tconst [pause, setPause] = useState(false);\n\tuseEffect(() => {\n\t\tif (options.size === \"\") {\n\t\t\thistory.push(\"/\");\n\t\t}\n\t\t// document.getElementById(\"sudoku\").innerHTML = \"\";\n\t\tconst sudokuBoard = $(\"#sudoku\").sudokuJS({\n\t\t\tdifficulty: options.level,\n\t\t\tboardSize: parseInt(options.size),\n\t\t});\n\n\t\t// document.getElementById(\"sudoku\").innerHTML += `\n\t\t// <div className=\"play\">\n\t\t// \t<i className=\"fas fa-play-circle\" id=\"fa-play-circle\"></i>\n\t\t// </div>\n\t\t// `;\n\t\t// document.getElementById(\"fa-play-circle\").addEventListener(\"click\", () => {\n\t\t// \tsetPause(!pause);\n\t\t// });\n\t\t// const sudokuBoardCells = document.querySelectorAll(\".sudoku-board-cell\");\n\n\t\tif (options.level === \"easy\") {\n\t\t\tfor (let i = 0; i <= 20; i++) {\n\t\t\t\tsudokuBoard.solveStep();\n\t\t\t}\n\t\t}\n\t\tsetMySudokoJS(sudokuBoard);\n\t}, []);\n\n\tif (options.size === \"\") {\n\t\treturn \"\";\n\t}\n\treturn (\n\t\t<div className=\"game\">\n\t\t\t<h3>Sudoku</h3>\n\t\t\t<div className=\"timer\">\n\t\t\t\t<Timer paused={pause} setPaused={setPause} />\n\t\t\t\t{/* <div className=\"time\">{time}</div> */}\n\t\t\t\t<div\n\t\t\t\t\tclassName=\"pausebtn\"\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tsetPause(!pause);\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\t{pause ? <i className=\"fas fa-pause-circle\"></i> : <i className=\"fas fa-play-circle\"></i>}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<div className=\"su\">\n\t\t\t\t<div id=\"sudoku\" className=\"sudoku-board\"></div>\n\t\t\t\t{pause ? (\n\t\t\t\t\t<div className=\"play\">\n\t\t\t\t\t\t<a>\n\t\t\t\t\t\t\t<i\n\t\t\t\t\t\t\t\tclassName=\"fas fa-play-circle\"\n\t\t\t\t\t\t\t\tid=\"fa-play-circle\"\n\t\t\t\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\t\t\t\tsetPause(false);\n\t\t\t\t\t\t\t\t}}\n\t\t\t\t\t\t\t></i>\n\t\t\t\t\t\t</a>\n\t\t\t\t\t</div>\n\t\t\t\t) : (\n\t\t\t\t\t\"\"\n\t\t\t\t)}\n\t\t\t</div>\n\t\t\t<div className=\"buttons\">\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"nes-btn\"\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tmySudokuJS.solveAll();\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tSolve\n\t\t\t\t</button>\n\n\t\t\t\t<button\n\t\t\t\t\tclassName=\"nes-btn\"\n\t\t\t\t\tonClick={() => {\n\t\t\t\t\t\tmySudokuJS.solveStep();\n\t\t\t\t\t}}\n\t\t\t\t>\n\t\t\t\t\tHint\n\t\t\t\t</button>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nexport default Game;\n","import { useState } from \"react\";\nimport Landing from \"./components/Landing\";\nimport Game from \"./components/Game\";\n\nimport \"./App.css\";\nimport { HashRouter as Router, Route, Switch } from \"react-router-dom\";\n\nfunction App() {\n\tconst [options, setOptions] = useState({\n\t\tlevel: \"\",\n\t\tsize: \"\",\n\t});\n\treturn (\n\t\t<div className=\"App\">\n\t\t\t<Router>\n\t\t\t\t<Switch>\n\t\t\t\t\t<Route exact path=\"/\">\n\t\t\t\t\t\t<Landing options={options} setOptions={setOptions} />\n\t\t\t\t\t</Route>\n\t\t\t\t\t<Route exact path=\"/game\">\n\t\t\t\t\t\t<Game options={options} />\n\t\t\t\t\t</Route>\n\t\t\t\t</Switch>\n\t\t\t</Router>\n\t\t</div>\n\t);\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById(\"root\")\n);\n"],"sourceRoot":""}